/*!
*
* \file   raptor_test.cpp
*
* \brief  Implementation of raptor codes data operation APIs
*
*
* \par    Include files
*         -     
*
* \par    Copyright (c) 2011 Yeqing Wu
*
* This library is free software; you can redistribute it and/or modify it 
* under the terms of the GNU Lesser General Public License as published by 
* the Free Software Foundation. This software is developed by refering to the software wrote by Vicente Sirvent,
* but many parts(especially some critical parts) of the raptor codes in that software have not been implemented 
* and there are lots of bugs and logical errors in that software. So I re-design software and implement it.
*
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
* See the GNU Lesser General Public License for more details.
* You should have received a copy of the GNU Lesser General Public License along with this library; 
* if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
* 
* \version 
* Revision of last commit: $Rev$ 
* Author of last commit  : $Author$ 
* Date of last commit    : $Date$ 
*
*/

//#include <vld.h>
#include <stdio.h>

#include <windows.h>

#include "raptor_defines.h"
#include "raptor_triple.h"
#include "raptor_encoder.h"
#include "raptor_decoder.h"

using std::queue;
using std::vector;

U32 FRAMELEN_SET;

//#define TEST_PURPOSE 1

#define random(x) (rand() % x)

U32 pos = 0, poslast = 0, FrameNum = 0;

extern U32 DecodeState;

unsigned long get_file_length(FILE* file_ptr)
{
          unsigned long  PosCur = 0;
          unsigned long  PosBegin = 0;
          unsigned long  PosEnd = 0;

          if( NULL == file_ptr )
          {
              return 0;
          }

          PosCur = ftell(file_ptr);
          fseek(file_ptr, 0L, SEEK_SET);
          PosBegin = ftell(file_ptr );
          fseek(file_ptr, 0L, SEEK_END);
          PosEnd = ftell( file_ptr );
          fseek(file_ptr, PosCur, SEEK_SET);

          return PosEnd-PosBegin;
}

static U8 *Find_VOP_Start(U8 *addrp, unsigned int FindSizes)
{
	while(pos < FindSizes)
	{
		if(addrp[pos] == 0x00)
		if(addrp[pos + 1] == 0x00)
		if(addrp[pos + 2] == 0x01)
		if(addrp[pos + 3] == 0xB0)
		{
			FrameNum++;
			//printf("%d\n", FrameNum);
			break;		//判断是否是VOS头；
		}

		if(addrp[pos] == 0x00)
		if(addrp[pos + 1] == 0x00)
		if(addrp[pos + 2] == 0x01)
		if(addrp[pos + 3] == 0xB6)
		{
			FrameNum++;
			//printf("%d\n", FrameNum);
			break;		 //判断是否是VOP头
		}

		pos++;
	}

	if(pos < FindSizes - 4)
	{
		return addrp+pos+4;
	}
	else
	return NULL;
}


U32 test_triple_generator(void)
{
  CTripleGenerator gen;
  U32 k = 1024;
  for (U32 x = 0; x < k; ++x)
  {
    CTriple triple = gen.Trip(k, x);
  }

  return 0;
}

queue<CData*> encoder_test(U8 *buffer, U32 k, U32 dataLen, U32 lossNum, U32 EXTNUM, CData **result)
{
  U32 R10Enc1 = GetTickCount();
  CEncoder encoder(k, lossNum, EXTNUM);

  const U32 DATA_LEN = 4096;
  U8 rndData[DATA_LEN];

  //printf("\nSource symbols generated by random\n");
  U32 index = 0;
  for (U32 i = 0; i < k; ++i)
  {
    for (U32 j = 0; j < dataLen; ++j)
    {
      //rndData[j] = rand();
      rndData[j] = buffer[i * dataLen + j];
      //printf("%d ", rndData[j]);
#ifdef TEST_PURPOSE
      index++;
      printf("%6d", rndData[j]);
      if ((index % SHOW_NUMS) == 0)
      {
        printf("\n");
      }
#endif
    }
    CData data(rndData, dataLen);
    encoder.AddData(&data, result);
  }
  U32 R10Enc2 = GetTickCount() - R10Enc1;
  printf("Encoding Time: %d, ", R10Enc2);

  //free(TransSeq);
  //TransSeq = NULL;

  return encoder.encoded_sym;
}

U32 decoder_test(U32 k, queue<CData* > &encoded_sym, U32 N, U32 lossNum, vector<U32> &ESI_vector, U32 FrameLen_now)
{
  CDecoder decoder(k, N, lossNum, ESI_vector);

  S32 t2 = GetTickCount();
  decoder.Decode(encoded_sym, FrameLen_now);

  S32 t1 = GetTickCount() - t2;
  printf("Decoding Time: %d\n", t1);
  //t2 = GetTickCount();

  return DecodeState;
}

S32 compare(const void* a, const void* b)
{
  return (*(S32* )a - *(S32* )b);
}

U32 R10_Codec(U32 k, U32  dataLen, U32 lossNum, U32 FrameLen_now, U32 EXTNUM, U8 *TransSeq, CData **result)
{
	queue<CData* > encoded_sym;
	U32 encodedSymSize;
  	U32* lossDataIndex;
  	U32 lossIndex = 0;
  	vector<U32> ESI_vector;
  	//U32 receivedSymSize;
  	BOOL isFound;

	encoded_sym = encoder_test(TransSeq, k, dataLen, lossNum, EXTNUM, result);

    encodedSymSize = encoded_sym.size();
    //printf("Encoded Packet Total Numbers: %d\n", encodedSymSize);
    lossDataIndex = new U32[lossNum];
    
    for (lossIndex = 0; lossIndex < lossNum; ++lossIndex)
    {
  	  if(0 != lossIndex)
  	  {
  		  while(1)
  		  {
  			  lossDataIndex[lossIndex] = random(encodedSymSize);
  			  U32 i, breakflag = 1;
  			  //printf("loss: %d\n", lossDataIndex[lossIndex]);
  			  for(i = 0; i < lossIndex; i++)
  			  {
  				  if((lossDataIndex[lossIndex] == lossDataIndex[i])
  				  || (encodedSymSize < lossDataIndex[lossIndex]))
  				  {
  					  breakflag = 0;
  					  //printf("equal: %d\n", i);
  					  break;
  				  }
  				  //printf("unequal: %d\n", i);
  			  }
  			  if(1 == breakflag)break;
  		  }
  	  }
  	  else
  	  {
  		  lossDataIndex[lossIndex] = random(encodedSymSize);
  		  //printf("loss: %d\n", lossDataIndex[lossIndex]);
  	  }
    }

    qsort(lossDataIndex, lossNum, sizeof(U32), compare);

    ESI_vector.clear();
    isFound = false;
    for (U32 i = 0; i < encodedSymSize; ++i)
    {
      isFound = false;
      for (U32 j = 0; j < lossNum; ++j)
      {
        if (i == lossDataIndex[j])
        {
          isFound = true;
          break;    
        }
        else 
        {
          isFound = false;
        }
      }
      if (isFound == false)
      {
        ESI_vector.push_back(i);
      } 
    }

    //printf("--------------Decoder--------------\n");
    //printf("Loss Packet Numbers: %d\n", lossNum);
    U32 receivedSymSize = encoded_sym.size();
    U32 state = decoder_test(k, encoded_sym, receivedSymSize, lossNum, ESI_vector, FrameLen_now);
    //printf("STATE: %d\n", state);
	while(0 == encoded_sym.empty())
	{
		//printf("%d\n", encoded_sym.size());
		CData* Sresult = encoded_sym.front();
		delete[] Sresult->m_Data;
		Sresult->m_Data = NULL;
		//delete result; 
		//result = NULL;
		encoded_sym.pop();
	}

	delete[] lossDataIndex;
	lossDataIndex = NULL;

	return state;
}

U32 main(U32 argc, CHAR* argv[])
{
  U32 i, k;
  U32 dataLen;
  U32 lossNum;
  U32 EXTNUM;
  
  printf("Input the number of source symbols: ");
  scanf("%d", &k);

  //printf("Input the length of every source symbol(be multiples of 2): ");
  //scanf("%d", &dataLen);

  printf("Input the loss data number: ");
  scanf("%d", &lossNum);
  
  printf("Input the overhead data number: ");
  scanf("%d", &EXTNUM);
  EXTNUM = EXTNUM + lossNum;

  printf("Input the Video Packet Len: ");
  scanf("%d", &FRAMELEN_SET);

  FILE *fp;
  char filepath[] = "clip4.ts";
  unsigned char *pFrame;
  
  /*
  fp = fopen(filepath, "rb");
  U32 FileLen = get_file_length(fp) + (k - get_file_length(fp) % k);
  printf("FileLen: %d\n", FileLen);
  fclose(fp);
  fp = NULL;
  dataLen = FileLen / k;
  */

  U8 *TransSeq, *TransFile;
  U32 FrameLen = 0;
  //printf("ReadSeq.\n");
  fp = fopen(filepath, "rb");
  U32 FileLen = get_file_length(fp);
  TransFile = (U8*)malloc(FileLen);
  printf("FileLen: %d\n", FileLen);
  fread(TransFile, FileLen, 1, fp);
  
  pFrame = Find_VOP_Start(TransFile, FileLen);
  while(pFrame)
  {
  	pFrame = Find_VOP_Start(TransFile, FileLen);
  	pos = pos + 4;
  }
  printf("FrameNum: %d\n", FrameNum);
  pos = 0;
  poslast = 0;
  U32 FrameNumMain = FrameNum;
  
  //fclose(fp);
  //fp = NULL;
  U32 F;

  printf("\n\n--------------------------------------------------------------\n");
  U32 k_now = k;
  U32 FrameLen_now;

  CData** result = new CData*[8192];
  for(i = 0; i < 8192; i++)
  {
  	result[i] = new CData;
  }

  U32 PacketNum = 0, LossPacket = 0;
  for(F = 0; F < FrameNumMain; F++)
  {
  	//fp = fopen(filepath, "rb");
  	U32 index = poslast; 
	k = k_now;

	while(FRAMELEN_SET > FrameLen)
	{
		pFrame = Find_VOP_Start(TransFile, FileLen);
		FrameLen = pos - index;
		//printf("FrameLen_temp: %d\n", FrameLen);
		if(FrameLen > k)
		{
			dataLen = FrameLen / k;
		}
		else
		{
			dataLen = 1;
			k = FrameLen;
		}
		poslast = pos;
		pos = pos + 4;
	  	
	  	//printf("Frame Index: #%d, ", F);
	  	//printf("FrameLenTemp: %d\n", FrameLen);

		FrameLen_now = FrameLen;
		if(0 != FrameLen % (k * dataLen))
		{
			FrameLen = (FrameLen / dataLen + 1) * dataLen;
			k = FrameLen / dataLen;
		}
		//printf("SourceNum: %d\n", k);
		//printf("DataLen: %d\n", dataLen);
		if(FRAMELEN_SET > FrameLen)F++;
	}

	printf("Frame Index: #%d, ", F);
	printf("FrameLen: %d, ", FrameLen);
	TransSeq = (U8*)malloc(FrameLen);
	for(i = 0; i < FrameLen; i++)
	{
		TransSeq[i] = 0;
	}
	  	
	//printf("Index: %d, ", index);
	fseek(fp, index, SEEK_SET);
	fread(TransSeq, FrameLen_now, 1, fp);
	FrameLen = 0;

    LossPacket = LossPacket + R10_Codec(k, dataLen, lossNum, FrameLen_now, EXTNUM, TransSeq, result);
    PacketNum++;
    
    //printf("--------------------------------------------------------------\n");
    free(TransSeq);
    TransSeq = NULL;
  }

  printf("--------------------------------------------------------------\n");
  printf("TransPacketNum: %d\n", PacketNum);
  printf("LossPacketNum: %d\n", LossPacket);
  
  for(i = 0; i < 8192; i++)
  {
  	delete result[i];
  	result[i] = NULL;
  }
  delete result;
  result = NULL;
  
  fclose(fp);
  fp = NULL;
  free(TransFile);
  TransFile = NULL;
  
  return 0;
}
